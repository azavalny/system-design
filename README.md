# System Design
System design, architecture, and databases explained from the *Software Architecture & Technology of Large-Scale Systems* Udemy Course and *Designing Data Intensive Applications* book for leveling up your software engineering skills and preparing for interviews


### Key Vocabulary:
* Throughput - # of requests processed/time
* Latency - how long request takes to be handled
    * Combination of wait/idle time for other resources and processing time of your programs
    * Response time is the result of what the client sees including latency + network delay to transport the result to the user

## Performance
Performance is defined as the responsiveness of your software under load with the goal of minimizing latency and maximizing throughput

Performance reductions are the result of a queue buildup of requests or jobs caused by:
* Slow processing
* Limited resource capacity
* Synchronous processes that can be made concurrent

To improve latency, you can either:
1. Vertically scale by improving your Hardware (CPU, Network, Memory, Disk size)
2. Caching data frequently read and rarely modified (server has cache controls)

To improve throughput:
1. Improve concurrency mechanisms of concurrent requests/jobs
2. Make serial aspects concurrent to process more requests/jobs simultaneously
    1. Reducing how many lines of code locks cover through lock splitting for objects and lock striping for data structures inside objects
    2. Design around optimistic locking (use a version number column) over pessimistic locking to avoid locking the database

### Latency
Latency acts as a bottleneck for throughput which is why you should improve it first:
* Network:
    * Use compression via binary encoding Protobufs to reduce data size and cache data
    * Reuse application session and database connections
* Memory:
    * Use proper memory allocation techniques to reduce memory leaks, and cache data properly
    * Normalize your data to avoid duplication and wasted space
    * Choose good garbage collectors for cleaning weak/soft references to objects
* Disk:
    * Use indexes to speed queries and denormalize distributed data
    * Use SSDs and RAID configurations for hardware
    * Use zero copy to reduce copying data between memory buffers (from disk straight to network)
* CPU:
    * Use batch and asynchronous processing

Higher throughput means you can support more users greater than the peak

![](Performance/latency.png)
Tail latency is an important metric that measures 99th, 99.9th... response times to model how well your application handles peak load


![](Performance/amdahls_gunther_law.png)

Amdahl's law models the concurrency speedup by using more threads. After an initial sharp speedup, you will notice diminishing returns of concurrency because of the overhead of managing the threads as well as CPU context switching.

Gunther's law is Amdahl's law by taking into account coherence delay (caching of variables and syncing them across caches) and scaling dimension which is slower to maintain as you add more threads



## Scalability


## Databases
| Relational (SQL) | Document (NoSQL) |
|---|---|
| Support for joins| More flexible schemas and faster reading|
| Better for many:1 or many:many relationships| Better for one:many relationships like in trees |

Graph is better for modeling many:many common and complex relationships with edges as well as storing different object types in verticies

* Index - lookup reference to find rows
* Secondary Index - lookup reference to find rows based on other column values
* Primary Key - uniquely identifies a row
* Foreign Key - points to a row in another table

B-Tree - generalized binary search tree that stores keys and data/pointers to data making them faster for individual key queries
* middle key is made parent when new key is added thats greater than capacity (make sure tree is balanced and all leaf nodes at same depth)

B+ Tree - stores data only in leaf nodes linking them together in a linked list making them faster for range queries

OLTP (Online transaction processing) - fast, real time transactions on small number of records
OLAP (Online analytical processing) - analysis and reporting of the history of all records 

Data warehouse - low latency storage of large volumes of data for analytical processing requiring high availability

Column oriented storage stores values from each column together in seperate files so you only read columns used in query instead of all the values in the row
* More efficient for analytical queries over large datasets

Backward compatible - new code can read data generated by older code 
Forward compatible - older code can read data generated by newer code

Protobuf - serialize objects in binary format with field tags/aliases instead of key/values like in JSON with datatypes clearly specified
* forward compatible when incrementing new field tag for new fiels
* backward compatible as new fields are optional and tags have the same meaning

Avro - encode entire object and refer to schema for types of each field
* reader and writer schema compatability ensures backward compatibility

RPC (remote procedure call) - running code on another computer using a local function call
gRPC - RPC with protobufs for encoding objects and supporting streams